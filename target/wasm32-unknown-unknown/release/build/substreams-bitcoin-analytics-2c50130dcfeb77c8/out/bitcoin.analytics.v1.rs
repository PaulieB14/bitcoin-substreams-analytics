// This file is @generated by prost-build.
/// Main Events message containing all analytics data types
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Events {
    #[prost(message, repeated, tag = "1")]
    pub blocks: ::prost::alloc::vec::Vec<BlockData>,
    #[prost(message, repeated, tag = "2")]
    pub transactions: ::prost::alloc::vec::Vec<TransactionData>,
    #[prost(message, repeated, tag = "3")]
    pub address_activities: ::prost::alloc::vec::Vec<AddressActivity>,
    #[prost(message, repeated, tag = "4")]
    pub utxos: ::prost::alloc::vec::Vec<UtxoData>,
    #[prost(message, repeated, tag = "5")]
    pub mempool_stats: ::prost::alloc::vec::Vec<MemPoolStats>,
}
/// Block-level analytics data
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockData {
    #[prost(uint64, tag = "1")]
    pub block_number: u64,
    #[prost(string, tag = "2")]
    pub block_hash: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub timestamp: u64,
    #[prost(uint32, tag = "4")]
    pub size: u32,
    #[prost(uint32, tag = "5")]
    pub weight: u32,
    #[prost(uint32, tag = "6")]
    pub transaction_count: u32,
    /// Mining pool identification if available
    #[prost(string, tag = "7")]
    pub miner: ::prost::alloc::string::String,
    #[prost(uint32, tag = "8")]
    pub version: u32,
    /// As string to handle large numbers
    #[prost(string, tag = "9")]
    pub difficulty: ::prost::alloc::string::String,
    /// SegWit, Taproot adoption metrics
    #[prost(message, repeated, tag = "10")]
    pub protocol_features: ::prost::alloc::vec::Vec<ProtocolFeature>,
}
/// Transaction-level analytics data
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionData {
    #[prost(string, tag = "1")]
    pub transaction_hash: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub block_number: u64,
    #[prost(uint32, tag = "3")]
    pub size: u32,
    #[prost(uint32, tag = "4")]
    pub weight: u32,
    /// vSize
    #[prost(uint32, tag = "5")]
    pub virtual_size: u32,
    /// In satoshis
    #[prost(uint64, tag = "6")]
    pub fee: u64,
    /// Satoshis per vByte
    #[prost(double, tag = "7")]
    pub fee_rate: f64,
    #[prost(uint32, tag = "8")]
    pub input_count: u32,
    #[prost(uint32, tag = "9")]
    pub output_count: u32,
    /// In satoshis
    #[prost(uint64, tag = "10")]
    pub total_input_value: u64,
    /// In satoshis
    #[prost(uint64, tag = "11")]
    pub total_output_value: u64,
    #[prost(bool, tag = "12")]
    pub is_coinbase: bool,
    #[prost(enumeration = "TransactionType", tag = "13")]
    pub r#type: i32,
    #[prost(string, repeated, tag = "14")]
    pub input_addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "15")]
    pub output_addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Address activity data
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddressActivity {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub block_number: u64,
    #[prost(string, tag = "3")]
    pub transaction_hash: ::prost::alloc::string::String,
    /// Send or Receive
    #[prost(enumeration = "ActivityType", tag = "4")]
    pub r#type: i32,
    /// In satoshis
    #[prost(uint64, tag = "5")]
    pub value: u64,
    /// Current balance after transaction
    #[prost(uint64, tag = "6")]
    pub balance: u64,
    /// Number of UTXOs for this address
    #[prost(uint32, tag = "7")]
    pub utxo_count: u32,
}
/// UTXO data
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UtxoData {
    #[prost(string, tag = "1")]
    pub transaction_hash: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub output_index: u32,
    #[prost(uint64, tag = "3")]
    pub block_number: u64,
    /// In satoshis
    #[prost(uint64, tag = "4")]
    pub value: u64,
    #[prost(bool, tag = "5")]
    pub is_spent: bool,
    #[prost(string, tag = "6")]
    pub spending_transaction_hash: ::prost::alloc::string::String,
    #[prost(uint64, tag = "7")]
    pub spending_block_number: u64,
    /// Address controlling this UTXO
    #[prost(string, tag = "8")]
    pub address: ::prost::alloc::string::String,
    /// Age in blocks
    #[prost(uint64, tag = "9")]
    pub age: u64,
}
/// Mempool statistics
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MemPoolStats {
    #[prost(uint64, tag = "1")]
    pub timestamp: u64,
    #[prost(uint32, tag = "2")]
    pub transaction_count: u32,
    /// In satoshis
    #[prost(uint64, tag = "3")]
    pub total_fee: u64,
    /// Satoshis per vByte
    #[prost(double, tag = "4")]
    pub median_fee_rate: f64,
    #[prost(message, optional, tag = "5")]
    pub fee_distribution: ::core::option::Option<FeeDistribution>,
    /// In bytes
    #[prost(uint64, tag = "6")]
    pub total_mempool_size: u64,
}
/// Fee distribution for different priority levels
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeeDistribution {
    /// For next block (satoshis/vByte)
    #[prost(double, tag = "1")]
    pub high_priority_fee_rate: f64,
    /// For next few blocks (satoshis/vByte)
    #[prost(double, tag = "2")]
    pub medium_priority_fee_rate: f64,
    /// For eventual confirmation (satoshis/vByte)
    #[prost(double, tag = "3")]
    pub low_priority_fee_rate: f64,
}
/// Protocol feature adoption metrics
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtocolFeature {
    /// SegWit, Taproot, etc.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Number of transactions using this feature
    #[prost(uint32, tag = "2")]
    pub count: u32,
    /// Percentage of total transactions
    #[prost(double, tag = "3")]
    pub percentage: f64,
}
/// Maps for aggregated statistics
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockStats {
    #[prost(map = "uint64, message", tag = "1")]
    pub blocks: ::std::collections::HashMap<u64, BlockData>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionStats {
    #[prost(map = "string, message", tag = "1")]
    pub transactions: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        TransactionData,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddressStats {
    #[prost(map = "string, message", tag = "1")]
    pub activities: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AddressActivity,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UtxoStats {
    #[prost(map = "string, message", tag = "1")]
    pub utxos: ::std::collections::HashMap<::prost::alloc::string::String, UtxoData>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MempoolData {
    /// Timestamp to stats mapping
    #[prost(map = "uint64, message", tag = "1")]
    pub stats: ::std::collections::HashMap<u64, MemPoolStats>,
}
/// Transaction types
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransactionType {
    Unspecified = 0,
    Standard = 1,
    Segwit = 2,
    Taproot = 3,
    Multisig = 4,
    Lightning = 5,
}
impl TransactionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TRANSACTION_TYPE_UNSPECIFIED",
            Self::Standard => "TRANSACTION_TYPE_STANDARD",
            Self::Segwit => "TRANSACTION_TYPE_SEGWIT",
            Self::Taproot => "TRANSACTION_TYPE_TAPROOT",
            Self::Multisig => "TRANSACTION_TYPE_MULTISIG",
            Self::Lightning => "TRANSACTION_TYPE_LIGHTNING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRANSACTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "TRANSACTION_TYPE_STANDARD" => Some(Self::Standard),
            "TRANSACTION_TYPE_SEGWIT" => Some(Self::Segwit),
            "TRANSACTION_TYPE_TAPROOT" => Some(Self::Taproot),
            "TRANSACTION_TYPE_MULTISIG" => Some(Self::Multisig),
            "TRANSACTION_TYPE_LIGHTNING" => Some(Self::Lightning),
            _ => None,
        }
    }
}
/// Activity types
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ActivityType {
    Unspecified = 0,
    Send = 1,
    Receive = 2,
}
impl ActivityType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ACTIVITY_TYPE_UNSPECIFIED",
            Self::Send => "ACTIVITY_TYPE_SEND",
            Self::Receive => "ACTIVITY_TYPE_RECEIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACTIVITY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ACTIVITY_TYPE_SEND" => Some(Self::Send),
            "ACTIVITY_TYPE_RECEIVE" => Some(Self::Receive),
            _ => None,
        }
    }
}
